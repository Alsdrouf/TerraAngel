--- src/Terraria/Terraria/GameContent/Drawing/TileDrawing.cs
+++ src/TerraAngel/Terraria/GameContent/Drawing/TileDrawing.cs
@@ -90,8 +_,6 @@
     private Color _highQualityLightingRequirement;
     private Color _mediumQualityLightingRequirement;
     private static readonly Vector2 _zero;
-    private ThreadLocal<TileDrawInfo> _currentTileDrawInfo = new ThreadLocal<TileDrawInfo>(() => new TileDrawInfo());
-    private TileDrawInfo _currentTileDrawInfoNonThreaded = new TileDrawInfo();
     private Vector3[] _glowPaintColorSlices = new Vector3[9] { Vector3.One, Vector3.One, Vector3.One, Vector3.One, Vector3.One, Vector3.One, Vector3.One, Vector3.One, Vector3.One };
     private List<DrawData> _voidLensData = new List<DrawData>();
     private bool[] _tileSolid => Main.tileSolid;
@@ -138,10 +_,6 @@
             for (int j = firstTileX - 2; j < lastTileX + 2; j++)
             {
                 Tile tile = Main.tile[j, i];
-                if (tile == null)
-                {
-                    continue;
-                }
 
                 if (tile.active())
                 {
@@ -384,7 +_,6 @@
             for (int j = firstTileX - 2; j < lastTileX + 2; j++)
             {
                 Tile tile = Main.tile[j, i];
-                if (tile != null)
                 {
                     DrawTile_LiquidBehindTile(solidLayer: false, inFrontOfPlayers: false, waterStyleOverride, unscaledPosition, vector, j, i, tile);
                 }
@@ -429,31 +_,24 @@
         GetScreenDrawArea(unscaledPosition, vector + (Main.Camera.UnscaledPosition - Main.Camera.ScaledPosition), out var firstTileX, out var lastTileX, out var firstTileY, out var lastTileY);
         byte b = (byte)(100f + 150f * Main.martianLight);
         _martianGlow = new Color(b, b, b, 0);
-        TileDrawInfo value = _currentTileDrawInfo.Value;
+        TileDrawInfo value = new TileDrawInfo();
+        SpriteBatch spriteBatch = Main.spriteBatch;
         for (int i = firstTileY; i < lastTileY + 4; i++)
         {
             for (int j = firstTileX - 2; j < lastTileX + 2; j++)
             {
                 Tile tile = Main.tile[j, i];
-                if (tile == null)
-                {
-                    tile = new Tile();
-                    Main.tile[j, i] = tile;
-                    Main.mapTime += 60;
-                }
-                else
-                {
                     if (!tile.active() || IsTileDrawLayerSolid(tile.type) != solidLayer)
                     {
                         continue;
                     }
-
                     if (solidLayer)
                     {
                         DrawTile_LiquidBehindTile(solidLayer, inFrontOfPlayers: false, waterStyleOverride, unscaledPosition, vector, j, i, tile);
                     }
 
                     ushort type = tile.type;
+
                     short frameX = tile.frameX;
                     short frameY = tile.frameY;
                     if (!TextureAssets.Tile[type].IsLoaded)
@@ -672,8 +_,98 @@
                             break;
                     }
 
-                    DrawSingleTile(value, solidLayer, waterStyleOverride, unscaledPosition, vector, j, i);
-                }
+                    if (TerraAngel.Hooks.Hooks.DrawHooks.LightModificationCache?.FullBright ?? false)
+                    {
+                    Color tileColor = new Color(new Vector3(TerraAngel.Hooks.Hooks.DrawHooks.LightModificationCache.Brightness));
+                    ushort typeCache = tile.type;
+                    short tileFrameX = tile.frameX;
+                    short tileFrameY = tile.frameY;
+                    GetTileDrawData(j, i, tile, typeCache, ref tileFrameX, ref tileFrameY, out value.tileWidth, out value.tileHeight, out value.tileTop, out value.halfBrickHeight, out value.addFrX, out value.addFrY, out value.tileSpriteEffect, out value.glowTexture, out value.glowSourceRect, out value.glowColor);
+                    Texture2D texture = GetTileDrawTexture(tile, j, i);
+                    Rectangle normalTileRect = new Rectangle(tileFrameX + value.addFrX, tileFrameY + value.addFrY, value.tileWidth, value.tileHeight - value.halfBrickHeight);
+                    Vector2 normalTilePosition = new Vector2((float)(j * 16 - (int)unscaledPosition.X) - ((float)value.tileWidth - 16f) / 2f, i * 16 - (int)unscaledPosition.Y + value.tileTop + value.halfBrickHeight) + vector;
+
+                    int slope = tile.slope();
+                    if (slope > 0)
+                    {
+                        if (TileID.Sets.Platforms[typeCache])
+                        {
+                            spriteBatch.Draw(texture, normalTilePosition, normalTileRect, tileColor, 0f, _zero, 1f, value.tileSpriteEffect, 0f);
+                            if (slope == 1 && Main.tile[j + 1, i + 1].active() && Main.tileSolid[Main.tile[j + 1, i + 1].type] && Main.tile[j + 1, i + 1].slope() != 2 && !Main.tile[j + 1, i + 1].halfBrick() && (!Main.tile[j, i + 1].active() || (Main.tile[j, i + 1].blockType() != 0 && Main.tile[j, i + 1].blockType() != 5) || (!TileID.Sets.BlocksStairs[Main.tile[j, i + 1].type] && !TileID.Sets.BlocksStairsAbove[Main.tile[j, i + 1].type])))
+                            {
+                                Rectangle rectValue = new Rectangle(198, tileFrameY, 16, 16);
+                                if (TileID.Sets.Platforms[Main.tile[j + 1, i + 1].type] && Main.tile[j + 1, i + 1].slope() == 0)
+                                {
+                                    rectValue.X = 324;
+                                }
+
+                                spriteBatch.Draw(texture, normalTilePosition + new Vector2(0f, 16f), rectValue, tileColor, 0f, _zero, 1f, value.tileSpriteEffect, 0f);
+                            }
+                            else if (slope == 2 && Main.tile[j - 1, i + 1].active() && Main.tileSolid[Main.tile[j - 1, i + 1].type] && Main.tile[j - 1, i + 1].slope() != 1 && !Main.tile[j - 1, i + 1].halfBrick() && (!Main.tile[j, i + 1].active() || (Main.tile[j, i + 1].blockType() != 0 && Main.tile[j, i + 1].blockType() != 4) || (!TileID.Sets.BlocksStairs[Main.tile[j, i + 1].type] && !TileID.Sets.BlocksStairsAbove[Main.tile[j, i + 1].type])))
+                            {
+                                Rectangle value2 = new Rectangle(162, tileFrameY, 16, 16);
+                                if (TileID.Sets.Platforms[Main.tile[j - 1, i + 1].type] && Main.tile[j - 1, i + 1].slope() == 0)
+                                {
+                                    value2.X = 306;
+                                }
+
+                                spriteBatch.Draw(texture, normalTilePosition + new Vector2(0f, 16f), value2, tileColor, 0f, _zero, 1f, value.tileSpriteEffect, 0f);
+                            }
+
+                            continue;
+                        }
+                        if (TileID.Sets.HasSlopeFrames[typeCache])
+                        {
+                            spriteBatch.Draw(texture, normalTilePosition, new Rectangle(tileFrameX + value.addFrX, tileFrameY + value.addFrY, 16, 16), tileColor, 0f, _zero, 1f, value.tileSpriteEffect, 0f);
+                            continue;
+                        }
+
+                        int l_num = slope;
+                        int l_num2 = 2;
+                        for (int l_i = 0; l_i < 8; l_i++)
+                        {
+                            int l_num3 = l_i * -2;
+                            int l_num4 = 16 - l_i * 2;
+                            int l_num5 = 16 - l_num4;
+                            int l_num6;
+                            switch (l_num)
+                            {
+                                case 1:
+                                    l_num3 = 0;
+                                    l_num6 = l_i * 2;
+                                    l_num4 = 14 - l_i * 2;
+                                    l_num5 = 0;
+                                    break;
+                                case 2:
+                                    l_num3 = 0;
+                                    l_num6 = 16 - l_i * 2 - 2;
+                                    l_num4 = 14 - l_i * 2;
+                                    l_num5 = 0;
+                                    break;
+                                case 3:
+                                    l_num6 = l_i * 2;
+                                    break;
+                                default:
+                                    l_num6 = 16 - l_i * 2 - 2;
+                                    break;
+                            }
+
+                            spriteBatch.Draw(texture, normalTilePosition + new Vector2(l_num6, l_i * l_num2 + l_num3), new Rectangle(tileFrameX + value.addFrX + l_num6, tileFrameY + value.addFrY + l_num5, l_num2, l_num4), tileColor, 0f, _zero, 1f, value.tileSpriteEffect, 0f);
+                        }
+
+                        int l_num7 = ((l_num <= 2) ? 14 : 0);
+                        spriteBatch.Draw(texture, normalTilePosition + new Vector2(0f, l_num7), new Rectangle(tileFrameX + value.addFrX, tileFrameY + value.addFrY + l_num7, 16, 2), tileColor, 0f, _zero, 1f, value.tileSpriteEffect, 0f);
+                        continue;
+                    }
+                    else
+                    {
+                        spriteBatch.Draw(texture, normalTilePosition, normalTileRect, tileColor, 0f, _zero, 1f, value.tileSpriteEffect, 0f);
+                    }
+                    continue;
+                    }
+
+                    unsafe { value.tileDataCache = *tile.Data; }
+                    DrawSingleTile(ref value, solidLayer, waterStyleOverride, unscaledPosition, vector, j, i);
             }
         }
 
@@ -742,9 +_,8 @@
         }
     }
 
-    private void DrawSingleTile(TileDrawInfo drawData, bool solidLayer, int waterStyleOverride, Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY)
+    private void DrawSingleTile(ref TileDrawInfo drawData, bool solidLayer, int waterStyleOverride, Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY)
     {
-        drawData.tileCache = Main.tile[tileX, tileY];
         drawData.typeCache = drawData.tileCache.type;
         drawData.tileFrameX = drawData.tileCache.frameX;
         drawData.tileFrameY = drawData.tileCache.frameY;
@@ -757,7 +_,6 @@
         GetTileDrawData(tileX, tileY, drawData.tileCache, drawData.typeCache, ref drawData.tileFrameX, ref drawData.tileFrameY, out drawData.tileWidth, out drawData.tileHeight, out drawData.tileTop, out drawData.halfBrickHeight, out drawData.addFrX, out drawData.addFrY, out drawData.tileSpriteEffect, out drawData.glowTexture, out drawData.glowSourceRect, out drawData.glowColor);
         drawData.drawTexture = GetTileDrawTexture(drawData.tileCache, tileX, tileY);
         Texture2D highlightTexture = null;
-        Rectangle empty = Rectangle.Empty;
         Color highlightColor = Color.Transparent;
         if (TileID.Sets.HasOutlines[drawData.typeCache])
         {
@@ -1011,15 +_,15 @@
 
         if (drawData.typeCache == 314)
         {
-            DrawTile_MinecartTrack(screenPosition, screenOffset, tileX, tileY, drawData);
+            DrawTile_MinecartTrack(screenPosition, screenOffset, tileX, tileY, ref drawData);
         }
         else if (drawData.typeCache == 171)
         {
-            DrawXmasTree(screenPosition, screenOffset, tileX, tileY, drawData);
+            DrawXmasTree(screenPosition, screenOffset, tileX, tileY, ref drawData);
         }
         else
         {
-            DrawBasicTile(screenPosition, screenOffset, tileX, tileY, drawData, rectangle, vector);
+            DrawBasicTile(screenPosition, screenOffset, tileX, tileY, ref drawData, rectangle, vector);
         }
 
         if (Main.tileGlowMask[drawData.tileCache.type] != -1)
@@ -1205,10 +_,8 @@
 
         if (highlightTexture != null)
         {
-            empty = new Rectangle(drawData.tileFrameX + drawData.addFrX, drawData.tileFrameY + drawData.addFrY, drawData.tileWidth, drawData.tileHeight);
-            int num19 = 0;
-            int num20 = 0;
-            Main.spriteBatch.Draw(highlightTexture, new Vector2((float)(tileX * 16 - (int)screenPosition.X) - ((float)drawData.tileWidth - 16f) / 2f + (float)num19, tileY * 16 - (int)screenPosition.Y + drawData.tileTop + num20) + screenOffset, empty, highlightColor, 0f, _zero, 1f, drawData.tileSpriteEffect, 0f);
+            Rectangle rect = new Rectangle(drawData.tileFrameX + drawData.addFrX, drawData.tileFrameY + drawData.addFrY, drawData.tileWidth, drawData.tileHeight);
+            Main.spriteBatch.Draw(highlightTexture, new Vector2((float)(tileX * 16 - (int)screenPosition.X) - ((float)drawData.tileWidth - 16f) / 2f, tileY * 16 - (int)screenPosition.Y + drawData.tileTop) + screenOffset, rect, highlightColor, 0f, _zero, 1f, drawData.tileSpriteEffect, 0f);
         }
     }
 
@@ -1302,9 +_,9 @@
         return result;
     }
 
-    private void DrawBasicTile(Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY, TileDrawInfo drawData, Rectangle normalTileRect, Vector2 normalTilePosition)
+    private void DrawBasicTile(Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY, ref TileDrawInfo drawData, Rectangle normalTileRect, Vector2 normalTilePosition)
     {
-        if (TileID.Sets.Platforms[drawData.typeCache] && WorldGen.IsRope(tileX, tileY) && Main.tile[tileX, tileY - 1] != null)
+        if (TileID.Sets.Platforms[drawData.typeCache] && WorldGen.IsRope(tileX, tileY))
         {
             _ = Main.tile[tileX, tileY - 1].type;
             int y = (tileY + tileX) % 3 * 18;
@@ -1317,7 +_,7 @@
 
         if (drawData.tileCache.slope() > 0)
         {
-            if (TileID.Sets.Platforms[drawData.tileCache.type])
+            if (TileID.Sets.Platforms[drawData.typeCache])
             {
                 Main.spriteBatch.Draw(drawData.drawTexture, normalTilePosition, normalTileRect, drawData.finalColor, 0f, _zero, 1f, drawData.tileSpriteEffect, 0f);
                 if (drawData.tileCache.slope() == 1 && Main.tile[tileX + 1, tileY + 1].active() && Main.tileSolid[Main.tile[tileX + 1, tileY + 1].type] && Main.tile[tileX + 1, tileY + 1].slope() != 2 && !Main.tile[tileX + 1, tileY + 1].halfBrick() && (!Main.tile[tileX, tileY + 1].active() || (Main.tile[tileX, tileY + 1].blockType() != 0 && Main.tile[tileX, tileY + 1].blockType() != 5) || (!TileID.Sets.BlocksStairs[Main.tile[tileX, tileY + 1].type] && !TileID.Sets.BlocksStairsAbove[Main.tile[tileX, tileY + 1].type])))
@@ -1439,7 +_,7 @@
 
         if (Lighting.NotRetro && _tileSolid[drawData.typeCache] && !drawData.tileCache.halfBrick() && !TileID.Sets.DontDrawTileSliced[drawData.tileCache.type])
         {
-            DrawSingleTile_SlicedBlock(normalTilePosition, tileX, tileY, drawData);
+            DrawSingleTile_SlicedBlock(normalTilePosition, tileX, tileY, ref drawData);
             return;
         }
 
@@ -1545,7 +_,7 @@
 
     public static int GetTreeVariant(int x, int y)
     {
-        if (Main.tile[x, y] == null || !Main.tile[x, y].active())
+        if (!Main.tile[x, y].active())
         {
             return -1;
         }
@@ -2869,7 +_,7 @@
         return num;
     }
 
-    private void DrawSingleTile_SlicedBlock(Vector2 normalTilePosition, int tileX, int tileY, TileDrawInfo drawData)
+    private void DrawSingleTile_SlicedBlock(Vector2 normalTilePosition, int tileX, int tileY, ref TileDrawInfo drawData)
     {
         Color color = default(Color);
         Vector2 origin = default(Vector2);
@@ -2878,7 +_,7 @@
         Vector2 position = default(Vector2);
         if (drawData.tileLight.R > _highQualityLightingRequirement.R || drawData.tileLight.G > _highQualityLightingRequirement.G || drawData.tileLight.B > _highQualityLightingRequirement.B)
         {
-            Vector3[] slices = drawData.colorSlices;
+            Span<Vector3> slices = drawData.colorSlices;
             Lighting.GetColor9Slice(tileX, tileY, ref slices);
             Vector3 vector = drawData.tileLight.ToVector3();
             Vector3 tint = drawData.colorTint.ToVector3();
@@ -2940,23 +_,9 @@
                 position.Y = normalTilePosition.Y + (float)value.Y;
                 value.X += drawData.tileFrameX + drawData.addFrX;
                 value.Y += drawData.tileFrameY + drawData.addFrY;
-                int num = (int)(tileLight.X * 255f);
-                int num2 = (int)(tileLight.Y * 255f);
-                int num3 = (int)(tileLight.Z * 255f);
-                if (num > 255)
-                {
-                    num = 255;
-                }
-
-                if (num2 > 255)
-                {
-                    num2 = 255;
-                }
-
-                if (num3 > 255)
-                {
-                    num3 = 255;
-                }
+                int num = Math.Clamp((int)(tileLight.X * 255f), 0, 255);
+                int num2 = Math.Clamp((int)(tileLight.Y * 255f), 0, 255);
+                int num3 = Math.Clamp((int)(tileLight.Z * 255f), 0, 255);
 
                 num3 <<= 16;
                 num2 <<= 8;
@@ -2966,7 +_,7 @@
         }
         else if (drawData.tileLight.R > _mediumQualityLightingRequirement.R || drawData.tileLight.G > _mediumQualityLightingRequirement.G || drawData.tileLight.B > _mediumQualityLightingRequirement.B)
         {
-            Vector3[] slices2 = drawData.colorSlices;
+            Span<Vector3> slices2 = drawData.colorSlices;
             Lighting.GetColor4Slice(tileX, tileY, ref slices2);
             Vector3 vector2 = drawData.tileLight.ToVector3();
             Vector3 tint2 = drawData.colorTint.ToVector3();
@@ -3003,23 +_,9 @@
                 position.Y = normalTilePosition.Y + (float)value.Y;
                 value.X += drawData.tileFrameX + drawData.addFrX;
                 value.Y += drawData.tileFrameY + drawData.addFrY;
-                int num4 = (int)(tileLight.X * 255f);
-                int num5 = (int)(tileLight.Y * 255f);
-                int num6 = (int)(tileLight.Z * 255f);
-                if (num4 > 255)
-                {
-                    num4 = 255;
-                }
-
-                if (num5 > 255)
-                {
-                    num5 = 255;
-                }
-
-                if (num6 > 255)
-                {
-                    num6 = 255;
-                }
+                int num4 = Math.Clamp((int)(tileLight.X * 255f), 0, 255);
+                int num5 = Math.Clamp((int)(tileLight.Y * 255f), 0, 255);
+                int num6 = Math.Clamp((int)(tileLight.Z * 255f), 0, 255);
 
                 num6 <<= 16;
                 num5 <<= 8;
@@ -3033,9 +_,9 @@
         }
     }
 
-    private void DrawXmasTree(Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY, TileDrawInfo drawData)
+    private void DrawXmasTree(Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY, ref TileDrawInfo drawData)
     {
-        if (tileY - drawData.tileFrameY > 0 && drawData.tileFrameY == 7 && Main.tile[tileX, tileY - drawData.tileFrameY] != null)
+        if (tileY - drawData.tileFrameY > 0 && drawData.tileFrameY == 7)
         {
             drawData.tileTop -= 16 * drawData.tileFrameY;
             drawData.tileFrameX = Main.tile[tileX, tileY - drawData.tileFrameY].frameX;
@@ -3154,13 +_,13 @@
         }
     }
 
-    private void DrawTile_MinecartTrack(Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY, TileDrawInfo drawData)
+    private void DrawTile_MinecartTrack(Vector2 screenPosition, Vector2 screenOffset, int tileX, int tileY, ref TileDrawInfo drawData)
     {
         drawData.tileLight = GetFinalLight(drawData.tileCache, drawData.typeCache, drawData.tileLight, drawData.colorTint);
         Minecart.TrackColors(tileX, tileY, drawData.tileCache, out var frontColor, out var backColor);
         drawData.drawTexture = GetTileDrawTexture(drawData.tileCache, tileX, tileY, frontColor);
         Texture2D tileDrawTexture = GetTileDrawTexture(drawData.tileCache, tileX, tileY, backColor);
-        if (WorldGen.IsRope(tileX, tileY) && Main.tile[tileX, tileY - 1] != null)
+        if (WorldGen.IsRope(tileX, tileY))
         {
             _ = Main.tile[tileX, tileY - 1].type;
             int y = (tileY + tileX) % 3 * 18;
@@ -3211,29 +_,6 @@
         Tile tile2 = Main.tile[tileX - 1, tileY];
         Tile tile3 = Main.tile[tileX, tileY - 1];
         Tile tile4 = Main.tile[tileX, tileY + 1];
-        if (tile == null)
-        {
-            tile = new Tile();
-            Main.tile[tileX + 1, tileY] = tile;
-        }
-
-        if (tile2 == null)
-        {
-            tile2 = new Tile();
-            Main.tile[tileX - 1, tileY] = tile2;
-        }
-
-        if (tile3 == null)
-        {
-            tile3 = new Tile();
-            Main.tile[tileX, tileY - 1] = tile3;
-        }
-
-        if (tile4 == null)
-        {
-            tile4 = new Tile();
-            Main.tile[tileX, tileY + 1] = tile4;
-        }
 
         if (!tileCache.active() || tileCache.inActive() || _tileSolidTop[tileCache.type] || (tileCache.halfBrick() && (tile2.liquid > 160 || tile.liquid > 160) && Main.instance.waterfallManager.CheckForWaterfall(tileX, tileY)) || (TileID.Sets.BlocksWaterDrawingBehindSelf[tileCache.type] && tileCache.slope() == 0))
         {
@@ -6019,10 +_,6 @@
     private bool IsWindBlocked(int x, int y)
     {
         Tile tile = Main.tile[x, y];
-        if (tile == null)
-        {
-            return true;
-        }
 
         if (tile.wall > 0 && !WallID.Sets.AllowsWind[tile.wall])
         {
@@ -7496,7 +_,7 @@
             int x = point.X;
             int y = point.Y;
             Tile tile = Main.tile[x, y];
-            if (tile == null || !tile.active())
+            if (!tile.active())
             {
                 continue;
             }
@@ -7818,7 +_,7 @@
             int x = point.X;
             int y = point.Y;
             Tile tile = Main.tile[x, y];
-            if (tile == null || !tile.active() || !IsVisible(tile))
+            if (!tile.active() || !IsVisible(tile))
             {
                 continue;
             }
@@ -7882,7 +_,7 @@
             int x = point.X;
             int y = point.Y;
             Tile tile = Main.tile[x, y];
-            if (tile == null || !tile.active() || !IsVisible(tile))
+            if (!tile.active() || !IsVisible(tile))
             {
                 continue;
             }
@@ -8115,7 +_,7 @@
         {
             Point p = _specialPositions[num][i];
             Tile tile = Main.tile[p.X, p.Y];
-            if (tile != null && tile.active())
+            if (tile.active())
             {
                 Texture2D value = TextureAssets.Extra[198].Value;
                 int frameY = tile.frameX / 54;
@@ -8150,7 +_,7 @@
         {
             Point p = _specialPositions[num][i];
             Tile tile = Main.tile[p.X, p.Y];
-            if (tile == null || !tile.active())
+            if (!tile.active())
             {
                 continue;
             }
@@ -8254,7 +_,7 @@
             int sizeX = 1;
             int num4 = 1;
             Tile tile = Main.tile[x, num3];
-            if (tile != null && tile.active())
+            if (tile.active())
             {
                 switch (Main.tile[x, num3].type)
                 {
@@ -8347,7 +_,7 @@
             int sizeX = 1;
             int sizeY = 1;
             Tile tile = Main.tile[x, y];
-            if (tile != null && tile.active())
+            if (tile.active())
             {
                 switch (Main.tile[x, y].type)
                 {
@@ -8537,10 +_,6 @@
         for (int i = startY; i < Main.maxTilesY - 10; i++)
         {
             Tile tile = Main.tile[x, i];
-            if (tile == null)
-            {
-                continue;
-            }
 
             ushort type = tile.type;
             if (!tile.active() || !TileID.Sets.VineThreads[type])
@@ -8650,7 +_,6 @@
         for (int num6 = startY; num6 > 10; num6--)
         {
             Tile tile = Main.tile[x, num6];
-            if (tile != null)
             {
                 ushort type = tile.type;
                 if (!tile.active() || !TileID.Sets.ReverseVineThreads[type])
@@ -9102,11 +_,6 @@
     private bool IsAlchemyPlantHarvestable(int style)
     {
         if (style == 0 && Main.dayTime)
-        {
-            return true;
-        }
-
-        if (style == 1 && !Main.dayTime)
         {
             return true;
         }
